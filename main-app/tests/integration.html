<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‰åç«¯é›†æˆæµ‹è¯•</title>
    <link rel="stylesheet" href="../styles/design-system.css">
    <style>
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        .test-section {
            background: var(--surface);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border);
        }
        .test-result {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            margin: 0.5rem 0;
            font-family: monospace;
        }
        .test-pass {
            background: rgba(34, 197, 94, 0.1);
            color: #22c55e;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }
        .test-fail {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        .test-running {
            background: rgba(59, 130, 246, 0.1);
            color: #3b82f6;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        .test-button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            margin: 0.5rem;
        }
        .test-button:hover {
            background: var(--primary-hover);
        }
        .test-button:disabled {
            background: var(--muted);
            cursor: not-allowed;
        }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--muted);
            border-radius: 4px;
            overflow: hidden;
            margin: 1rem 0;
        }
        .progress-fill {
            height: 100%;
            background: var(--primary);
            transition: width 0.3s ease;
        }
        .test-log {
            background: #1a1a1a;
            color: #f0f0f0;
            padding: 1rem;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.9rem;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }
        .metric-card {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
        }
        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--primary);
        }
        .metric-label {
            color: var(--muted-foreground);
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <header class="test-section">
            <h1>ğŸ§ª å‰åç«¯é›†æˆæµ‹è¯•å¥—ä»¶</h1>
            <p>æµ‹è¯•å®Œæ•´çš„ç”¨æˆ·è¾“å…¥åˆ°å¯è§†åŒ–ç”Ÿæˆæµç¨‹</p>
            <button id="runAllTests" class="test-button">è¿è¡Œæ‰€æœ‰æµ‹è¯•</button>
            <button id="clearResults" class="test-button">æ¸…é™¤ç»“æœ</button>
        </header>

        <section class="test-section">
            <h2>ğŸ“Š æµ‹è¯•è¿›åº¦</h2>
            <div class="progress-bar">
                <div id="progressFill" class="progress-fill" style="width: 0%"></div>
            </div>
            <div id="progressText">å‡†å¤‡å°±ç»ª</div>
        </section>

        <section class="test-section">
            <h2>ğŸ¯ APIè¿æ¥æµ‹è¯•</h2>
            <div id="apiResults"></div>
            <button class="test-button" onclick="testAPIConnection()">æµ‹è¯•APIè¿æ¥</button>
        </section>

        <section class="test-section">
            <h2>ğŸ”„ ç«¯åˆ°ç«¯æµç¨‹æµ‹è¯•</h2>
            <div id="e2eResults"></div>
            <button class="test-button" onclick="testE2EFlow()">æµ‹è¯•å®Œæ•´æµç¨‹</button>
        </section>

        <section class="test-section">
            <h2>ğŸš¨ é”™è¯¯å¤„ç†æµ‹è¯•</h2>
            <div id="errorResults"></div>
            <button class="test-button" onclick="testErrorHandling()">æµ‹è¯•é”™è¯¯å¤„ç†</button>
        </section>

        <section class="test-section">
            <h2>ğŸ“± å“åº”å¼æµ‹è¯•</h2>
            <div id="responsiveResults"></div>
            <button class="test-button" onclick="testResponsive()">æµ‹è¯•å“åº”å¼</button>
        </section>

        <section class="test-section">
            <h2>ğŸ“ˆ æ€§èƒ½æŒ‡æ ‡</h2>
            <div class="metrics-grid">
                <div class="metric-card">
                    <div id="avgResponseTime" class="metric-value">-</div>
                    <div class="metric-label">å¹³å‡å“åº”æ—¶é—´(ms)</div>
                </div>
                <div class="metric-card">
                    <div id="successRate" class="metric-value">-</div>
                    <div class="metric-label">æˆåŠŸç‡(%)</div>
                </div>
                <div class="metric-card">
                    <div id="totalTests" class="metric-value">-</div>
                    <div class="metric-label">æ€»æµ‹è¯•æ•°</div>
                </div>
                <div class="metric-card">
                    <div id="testDuration" class="metric-value">-</div>
                    <div class="metric-label">æµ‹è¯•è€—æ—¶(s)</div>
                </div>
            </div>
        </section>

        <section class="test-section">
            <h2>ğŸ“ æµ‹è¯•æ—¥å¿—</h2>
            <div id="testLog" class="test-log">ç­‰å¾…æµ‹è¯•å¼€å§‹...</div>
        </section>
    </div>

    <!-- å¼•å…¥å¿…è¦çš„ç»„ä»¶ -->
    <script src="../app/components/ApiClient.js"></script>
    <script src="../app/components/StateManager.js"></script>
    <script src="../app/components/Router.js"></script>
    <script src="../app/components/VizContainer.js"></script>
    <script src="../app/components/LoadingStates.js"></script>

    <script>
        // æµ‹è¯•çŠ¶æ€ç®¡ç†
        let testState = {
            running: false,
            results: {
                api: [],
                e2e: [],
                error: [],
                responsive: []
            },
            metrics: {
                startTime: null,
                endTime: null,
                totalTests: 0,
                passedTests: 0,
                responseTimes: []
            }
        };

        // æ—¥å¿—è®°å½•
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.getElementById('testLog');
            const prefix = type === 'error' ? 'âŒ' : type === 'success' ? 'âœ…' : type === 'warning' ? 'âš ï¸' : 'â„¹ï¸';
            logElement.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
        }

        // æ›´æ–°è¿›åº¦
        function updateProgress(current, total) {
            const percentage = Math.round((current / total) * 100);
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('progressText').textContent = `è¿›åº¦: ${current}/${total} (${percentage}%)`;
        }

        // æ·»åŠ æµ‹è¯•ç»“æœ
        function addTestResult(containerId, testName, status, message = '', responseTime = null) {
            const container = document.getElementById(containerId);
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result test-${status}`;

            let content = `${testName}`;
            if (responseTime) {
                content += ` (${responseTime}ms)`;
            }
            if (message) {
                content += ` - ${message}`;
            }

            resultDiv.textContent = content;
            container.appendChild(resultDiv);

            // æ›´æ–°ç»Ÿè®¡
            testState.metrics.totalTests++;
            if (status === 'pass') {
                testState.metrics.passedTests++;
            }
            if (responseTime) {
                testState.metrics.responseTimes.push(responseTime);
            }

            return resultDiv;
        }

        // æµ‹è¯•APIè¿æ¥
        async function testAPIConnection() {
            log('å¼€å§‹APIè¿æ¥æµ‹è¯•...');
            const apiClient = new ApiClient();

            const tests = [
                { name: 'APIåŸºç¡€è¿æ¥', endpoint: '/api/resolve_or_generate' },
                { name: 'å¥åº·æ£€æŸ¥', endpoint: '/api/health' },
                { name: 'æ¨¡æ¿åˆ—è¡¨', endpoint: '/api/templates' }
            ];

            for (let i = 0; i < tests.length; i++) {
                const test = tests[i];
                const startTime = Date.now();

                try {
                    log(`æµ‹è¯•: ${test.name}`);
                    const response = await apiClient.request('GET', test.endpoint);
                    const responseTime = Date.now() - startTime;

                    if (response.ok) {
                        addTestResult('apiResults', test.name, 'pass', 'è¿æ¥æˆåŠŸ', responseTime);
                        log(`${test.name} - æˆåŠŸ (${responseTime}ms)`, 'success');
                    } else {
                        addTestResult('apiResults', test.name, 'fail', `HTTP ${response.status}`);
                        log(`${test.name} - å¤±è´¥: HTTP ${response.status}`, 'error');
                    }
                } catch (error) {
                    const responseTime = Date.now() - startTime;
                    addTestResult('apiResults', test.name, 'fail', error.message, responseTime);
                    log(`${test.name} - é”™è¯¯: ${error.message}`, 'error');
                }

                updateProgress(i + 1, tests.length);
            }

            log('APIè¿æ¥æµ‹è¯•å®Œæˆ');
        }

        // æµ‹è¯•ç«¯åˆ°ç«¯æµç¨‹
        async function testE2EFlow() {
            log('å¼€å§‹ç«¯åˆ°ç«¯æµç¨‹æµ‹è¯•...');

            const testCases = [
                {
                    name: 'æ•°å­¦å‡½æ•°å¯è§†åŒ–',
                    input: 'ç»˜åˆ¶ä¸€ä¸ªäºŒæ¬¡å‡½æ•° y = x^2 çš„å›¾åƒ',
                    expectedType: 'math'
                },
                {
                    name: 'å¤©ä½“è¿åŠ¨æ¨¡æ‹Ÿ',
                    input: 'æ˜¾ç¤ºåœ°çƒç»•å¤ªé˜³çš„è¿åŠ¨è½¨è¿¹',
                    expectedType: 'astronomy'
                },
                {
                    name: 'ç‰©ç†å®éªŒæ¼”ç¤º',
                    input: 'æ¨¡æ‹Ÿè‡ªç”±è½ä½“è¿åŠ¨',
                    expectedType: 'physics'
                }
            ];

            for (let i = 0; i < testCases.length; i++) {
                const testCase = testCases[i];
                const startTime = Date.now();

                try {
                    log(`æµ‹è¯•æµç¨‹: ${testCase.name}`);

                    // æ¨¡æ‹Ÿç”¨æˆ·è¾“å…¥
                    const inputResult = await simulateUserInput(testCase.input);
                    if (!inputResult.success) {
                        throw new Error('è¾“å…¥å¤„ç†å¤±è´¥');
                    }

                    // æ¨¡æ‹ŸAPIè°ƒç”¨
                    const apiResult = await simulateAPICall(testCase.input);
                    if (!apiResult.success) {
                        throw new Error('APIè°ƒç”¨å¤±è´¥');
                    }

                    // æ¨¡æ‹Ÿé¡µé¢åŠ è½½
                    const pageResult = await simulatePageLoad(apiResult.data);
                    if (!pageResult.success) {
                        throw new Error('é¡µé¢åŠ è½½å¤±è´¥');
                    }

                    const responseTime = Date.now() - startTime;
                    addTestResult('e2eResults', testCase.name, 'pass', 'æµç¨‹å®Œæ•´', responseTime);
                    log(`${testCase.name} - æˆåŠŸ (${responseTime}ms)`, 'success');

                } catch (error) {
                    const responseTime = Date.now() - startTime;
                    addTestResult('e2eResults', testCase.name, 'fail', error.message, responseTime);
                    log(`${testCase.name} - å¤±è´¥: ${error.message}`, 'error');
                }

                updateProgress(i + 1, testCases.length);
            }

            log('ç«¯åˆ°ç«¯æµç¨‹æµ‹è¯•å®Œæˆ');
        }

        // æµ‹è¯•é”™è¯¯å¤„ç†
        async function testErrorHandling() {
            log('å¼€å§‹é”™è¯¯å¤„ç†æµ‹è¯•...');

            const errorCases = [
                {
                    name: 'æ— æ•ˆè¾“å…¥å¤„ç†',
                    input: '',
                    expectedError: 'è¾“å…¥ä¸èƒ½ä¸ºç©º'
                },
                {
                    name: 'APIé”™è¯¯å“åº”',
                    input: 'è¿™ä¸ªè¾“å…¥ä¼šå¯¼è‡´APIé”™è¯¯',
                    simulateError: true
                },
                {
                    name: 'ç½‘ç»œè¿æ¥å¤±è´¥',
                    input: 'æ­£å¸¸è¾“å…¥',
                    simulateNetworkError: true
                }
            ];

            for (let i = 0; i < errorCases.length; i++) {
                const errorCase = errorCases[i];

                try {
                    log(`æµ‹è¯•é”™è¯¯: ${errorCase.name}`);

                    let result;
                    if (errorCase.simulateNetworkError) {
                        result = await simulateNetworkError();
                    } else if (errorCase.simulateError) {
                        result = await simulateAPIError();
                    } else {
                        result = await simulateValidationError(errorCase.input);
                    }

                    if (result.errorHandled) {
                        addTestResult('errorResults', errorCase.name, 'pass', 'é”™è¯¯æ­£ç¡®å¤„ç†');
                        log(`${errorCase.name} - é”™è¯¯å¤„ç†æ­£ç¡®`, 'success');
                    } else {
                        addTestResult('errorResults', errorCase.name, 'fail', 'é”™è¯¯å¤„ç†å¤±è´¥');
                        log(`${errorCase.name} - é”™è¯¯å¤„ç†å¤±è´¥`, 'error');
                    }

                } catch (error) {
                    addTestResult('errorResults', errorCase.name, 'fail', error.message);
                    log(`${errorCase.name} - æ„å¤–é”™è¯¯: ${error.message}`, 'error');
                }

                updateProgress(i + 1, errorCases.length);
            }

            log('é”™è¯¯å¤„ç†æµ‹è¯•å®Œæˆ');
        }

        // æµ‹è¯•å“åº”å¼
        async function testResponsive() {
            log('å¼€å§‹å“åº”å¼æµ‹è¯•...');

            const viewportSizes = [
                { name: 'æ¡Œé¢ç«¯', width: 1920, height: 1080 },
                { name: 'å¹³æ¿ç«¯', width: 768, height: 1024 },
                { name: 'æ‰‹æœºç«¯', width: 375, height: 667 }
            ];

            for (let i = 0; i < viewportSizes.length; i++) {
                const size = viewportSizes[i];

                try {
                    log(`æµ‹è¯•è§†å£: ${size.name} (${size.width}x${size.height})`);

                    // æ¨¡æ‹Ÿè§†å£å¤§å°å˜åŒ–
                    const result = await simulateViewportChange(size.width, size.height);

                    if (result.adaptive) {
                        addTestResult('responsiveResults', size.name, 'pass', 'å“åº”å¼é€‚é…æˆåŠŸ');
                        log(`${size.name} - å“åº”å¼é€‚é…æˆåŠŸ`, 'success');
                    } else {
                        addTestResult('responsiveResults', size.name, 'fail', 'å“åº”å¼é€‚é…å¤±è´¥');
                        log(`${size.name} - å“åº”å¼é€‚é…å¤±è´¥`, 'error');
                    }

                } catch (error) {
                    addTestResult('responsiveResults', size.name, 'fail', error.message);
                    log(`${size.name} - æµ‹è¯•é”™è¯¯: ${error.message}`, 'error');
                }

                updateProgress(i + 1, viewportSizes.length);
            }

            log('å“åº”å¼æµ‹è¯•å®Œæˆ');
        }

        // æ¨¡æ‹Ÿå‡½æ•°
        async function simulateUserInput(input) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve({ success: true, data: input });
                }, 100);
            });
        }

        async function simulateAPICall(input) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve({
                        success: true,
                        data: {
                            type: 'visualization',
                            content: 'ç”Ÿæˆçš„å¯è§†åŒ–å†…å®¹',
                            parameters: {}
                        }
                    });
                }, 500);
            });
        }

        async function simulatePageLoad(data) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve({ success: true, loaded: true });
                }, 300);
            });
        }

        async function simulateValidationError(input) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve({
                        errorHandled: input.length === 0,
                        message: input.length === 0 ? 'è¾“å…¥ä¸èƒ½ä¸ºç©º' : null
                    });
                }, 50);
            });
        }

        async function simulateAPIError() {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve({ errorHandled: true });
                }, 200);
            });
        }

        async function simulateNetworkError() {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve({ errorHandled: true });
                }, 1000);
            });
        }

        async function simulateViewportChange(width, height) {
            return new Promise((resolve) => {
                // æ¨¡æ‹Ÿå“åº”å¼æ£€æµ‹
                setTimeout(() => {
                    resolve({ adaptive: true });
                }, 100);
            });
        }

        // è¿è¡Œæ‰€æœ‰æµ‹è¯•
        async function runAllTests() {
            if (testState.running) {
                log('æµ‹è¯•æ­£åœ¨è¿è¡Œä¸­...', 'warning');
                return;
            }

            testState.running = true;
            testState.metrics.startTime = Date.now();

            document.getElementById('runAllTests').disabled = true;
            clearAllResults();
            log('å¼€å§‹è¿è¡Œæ‰€æœ‰æµ‹è¯•...');

            try {
                await testAPIConnection();
                await new Promise(resolve => setTimeout(resolve, 500));

                await testE2EFlow();
                await new Promise(resolve => setTimeout(resolve, 500));

                await testErrorHandling();
                await new Promise(resolve => setTimeout(resolve, 500));

                await testResponsive();

            } catch (error) {
                log(`æµ‹è¯•è¿è¡Œå‡ºé”™: ${error.message}`, 'error');
            } finally {
                testState.metrics.endTime = Date.now();
                testState.running = false;
                document.getElementById('runAllTests').disabled = false;
                updateMetrics();
                log('æ‰€æœ‰æµ‹è¯•å®Œæˆ!');
            }
        }

        // æ›´æ–°æ€§èƒ½æŒ‡æ ‡
        function updateMetrics() {
            const duration = (testState.metrics.endTime - testState.metrics.startTime) / 1000;
            const successRate = testState.metrics.totalTests > 0
                ? Math.round((testState.metrics.passedTests / testState.metrics.totalTests) * 100)
                : 0;
            const avgResponseTime = testState.metrics.responseTimes.length > 0
                ? Math.round(testState.metrics.responseTimes.reduce((a, b) => a + b, 0) / testState.metrics.responseTimes.length)
                : 0;

            document.getElementById('avgResponseTime').textContent = avgResponseTime;
            document.getElementById('successRate').textContent = successRate;
            document.getElementById('totalTests').textContent = testState.metrics.totalTests;
            document.getElementById('testDuration').textContent = duration.toFixed(1);
        }

        // æ¸…é™¤ç»“æœ
        function clearAllResults() {
            ['apiResults', 'e2eResults', 'errorResults', 'responsiveResults'].forEach(id => {
                document.getElementById(id).innerHTML = '';
            });
            document.getElementById('testLog').textContent = '';
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressText').textContent = 'å‡†å¤‡å°±ç»ª';

            // é‡ç½®æŒ‡æ ‡
            ['avgResponseTime', 'successRate', 'totalTests', 'testDuration'].forEach(id => {
                document.getElementById(id).textContent = '-';
            });

            // é‡ç½®çŠ¶æ€
            testState = {
                running: false,
                results: {
                    api: [],
                    e2e: [],
                    error: [],
                    responsive: []
                },
                metrics: {
                    startTime: null,
                    endTime: null,
                    totalTests: 0,
                    passedTests: 0,
                    responseTimes: []
                }
            };
        }

        // ç»‘å®šäº‹ä»¶
        document.getElementById('runAllTests').addEventListener('click', runAllTests);
        document.getElementById('clearResults').addEventListener('click', clearAllResults);

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            log('é›†æˆæµ‹è¯•å¥—ä»¶å·²åŠ è½½');
            log('ç‚¹å‡»"è¿è¡Œæ‰€æœ‰æµ‹è¯•"å¼€å§‹æµ‹è¯•');
        });
    </script>
</body>
</html>