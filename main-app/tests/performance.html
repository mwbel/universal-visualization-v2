<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ€§èƒ½åŸºå‡†æµ‹è¯•</title>
    <link rel="stylesheet" href="../styles/design-system.css">
    <style>
        .perf-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }
        .perf-section {
            background: var(--surface);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border);
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }
        .metric-card {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(147, 51, 234, 0.1));
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            text-align: center;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }
        .metric-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }
        .metric-label {
            color: var(--muted-foreground);
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }
        .metric-status {
            font-size: 0.8rem;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }
        .metric-status.warning {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }
        .metric-status.error {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }
        .test-button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            margin: 0.5rem;
            transition: all 0.2s ease;
        }
        .test-button:hover {
            background: var(--primary-hover);
            transform: translateY(-1px);
        }
        .test-button:disabled {
            background: var(--muted);
            cursor: not-allowed;
            transform: none;
        }
        .progress-container {
            margin: 2rem 0;
        }
        .progress-bar {
            width: 100%;
            height: 12px;
            background: var(--muted);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            transition: width 0.3s ease;
            position: relative;
        }
        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        .chart-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--muted-foreground);
        }
        .test-log {
            background: #0a0a0a;
            color: #e0e0e0;
            padding: 1rem;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.85rem;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            border: 1px solid var(--border);
        }
        .result-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }
        .result-table th,
        .result-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }
        .result-table th {
            background: rgba(59, 130, 246, 0.1);
            font-weight: 600;
            color: var(--primary);
        }
        .result-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }
        .status-indicator.good {
            background: #22c55e;
        }
        .status-indicator.warning {
            background: #f59e0b;
        }
        .status-indicator.error {
            background: #ef4444;
        }
        .comparison-chart {
            display: flex;
            align-items: end;
            height: 200px;
            gap: 1rem;
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
        }
        .chart-bar {
            flex: 1;
            background: linear-gradient(to top, var(--primary), var(--accent));
            border-radius: 4px 4px 0 0;
            position: relative;
            min-height: 20px;
            transition: all 0.3s ease;
        }
        .chart-bar:hover {
            opacity: 0.8;
        }
        .chart-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem;
            white-space: nowrap;
        }
        .chart-value {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="perf-container">
        <header class="perf-section">
            <h1>ğŸš€ æ€§èƒ½åŸºå‡†æµ‹è¯•å¥—ä»¶</h1>
            <p>å…¨é¢æµ‹è¯•ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡ï¼ŒåŒ…æ‹¬APIå“åº”ã€é¡µé¢åŠ è½½ã€å¹¶å‘å¤„ç†ç­‰</p>
            <div>
                <button id="runPerfTests" class="test-button">è¿è¡Œæ€§èƒ½æµ‹è¯•</button>
                <button id="runStressTest" class="test-button">å‹åŠ›æµ‹è¯•</button>
                <button id="clearResults" class="test-button">æ¸…é™¤ç»“æœ</button>
                <button id="exportReport" class="test-button">å¯¼å‡ºæŠ¥å‘Š</button>
            </div>
        </header>

        <section class="perf-section">
            <h2>ğŸ“Š æ ¸å¿ƒæ€§èƒ½æŒ‡æ ‡</h2>
            <div class="metrics-grid">
                <div class="metric-card">
                    <div id="apiResponseTime" class="metric-value">-</div>
                    <div class="metric-label">APIå¹³å‡å“åº”æ—¶é—´</div>
                    <div id="apiStatus" class="metric-status">å¾…æµ‹è¯•</div>
                </div>
                <div class="metric-card">
                    <div id="pageLoadTime" class="metric-value">-</div>
                    <div class="metric-label">é¡µé¢å¹³å‡åŠ è½½æ—¶é—´</div>
                    <div id="pageStatus" class="metric-status">å¾…æµ‹è¯•</div>
                </div>
                <div class="metric-card">
                    <div id="concurrentUsers" class="metric-value">-</div>
                    <div class="metric-label">å¹¶å‘ç”¨æˆ·æ”¯æŒ</div>
                    <div id="concurrentStatus" class="metric-status">å¾…æµ‹è¯•</div>
                </div>
                <div class="metric-card">
                    <div id="memoryUsage" class="metric-value">-</div>
                    <div class="metric-label">å†…å­˜ä½¿ç”¨é‡</div>
                    <div id="memoryStatus" class="metric-status">å¾…æµ‹è¯•</div>
                </div>
                <div class="metric-card">
                    <div id="cpuUsage" class="metric-value">-</div>
                    <div class="metric-label">CPUä½¿ç”¨ç‡</div>
                    <div id="cpuStatus" class="metric-status">å¾…æµ‹è¯•</div>
                </div>
                <div class="metric-card">
                    <div id="throughput" class="metric-value">-</div>
                    <div class="metric-label">ç³»ç»Ÿååé‡</div>
                    <div id="throughputStatus" class="metric-status">å¾…æµ‹è¯•</div>
                </div>
            </div>
        </section>

        <section class="perf-section">
            <h2>ğŸ“ˆ æµ‹è¯•è¿›åº¦</h2>
            <div class="progress-container">
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill" style="width: 0%"></div>
                </div>
                <div id="progressText">å‡†å¤‡å°±ç»ª</div>
            </div>
        </section>

        <section class="perf-section">
            <h2>âš¡ APIæ€§èƒ½æµ‹è¯•</h2>
            <table class="result-table">
                <thead>
                    <tr>
                        <th>ç«¯ç‚¹</th>
                        <th>å¹³å‡å“åº”æ—¶é—´</th>
                        <th>æœ€å°å“åº”æ—¶é—´</th>
                        <th>æœ€å¤§å“åº”æ—¶é—´</th>
                        <th>æˆåŠŸç‡</th>
                        <th>çŠ¶æ€</th>
                    </tr>
                </thead>
                <tbody id="apiPerfResults">
                    <tr>
                        <td colspan="6" style="text-align: center; color: var(--muted-foreground);">ç­‰å¾…æµ‹è¯•...</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section class="perf-section">
            <h2>ğŸ–¥ï¸ é¡µé¢åŠ è½½æ€§èƒ½</h2>
            <div class="comparison-chart" id="pageLoadChart">
                <div style="color: var(--muted-foreground);">é¡µé¢åŠ è½½æ•°æ®å°†åœ¨æ­¤æ˜¾ç¤º</div>
            </div>
            <table class="result-table">
                <thead>
                    <tr>
                        <th>é¡µé¢ç±»å‹</th>
                        <th>é¦–æ¬¡å†…å®¹ç»˜åˆ¶</th>
                        <th>æœ€å¤§å†…å®¹ç»˜åˆ¶</th>
                        <th>å®Œå…¨åŠ è½½æ—¶é—´</th>
                        <th>èµ„æºå¤§å°</th>
                        <th>çŠ¶æ€</th>
                    </tr>
                </thead>
                <tbody id="pageLoadResults">
                    <tr>
                        <td colspan="6" style="text-align: center; color: var(--muted-foreground);">ç­‰å¾…æµ‹è¯•...</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section class="perf-section">
            <h2>ğŸ”„ å¹¶å‘æ€§èƒ½æµ‹è¯•</h2>
            <div class="chart-container" id="concurrentChart">
                å¹¶å‘æµ‹è¯•å›¾è¡¨å°†åœ¨æ­¤æ˜¾ç¤º
            </div>
            <div class="metrics-grid">
                <div class="metric-card">
                    <div id="maxConcurrent" class="metric-value">-</div>
                    <div class="metric-label">æœ€å¤§å¹¶å‘æ•°</div>
                </div>
                <div class="metric-card">
                    <div id="avgConcurrentTime" class="metric-value">-</div>
                    <div class="metric-label">å¹³å‡å¹¶å‘å“åº”æ—¶é—´</div>
                </div>
                <div class="metric-card">
                    <div id="errorRate" class="metric-value">-</div>
                    <div class="metric-label">é”™è¯¯ç‡</div>
                </div>
            </div>
        </section>

        <section class="perf-section">
            <h2>ğŸ’¾ èµ„æºä½¿ç”¨ç›‘æ§</h2>
            <div class="metrics-grid">
                <div class="metric-card">
                    <div id="initialMemory" class="metric-value">-</div>
                    <div class="metric-label">åˆå§‹å†…å­˜</div>
                </div>
                <div class="metric-card">
                    <div id="peakMemory" class="metric-value">-</div>
                    <div class="metric-label">å³°å€¼å†…å­˜</div>
                </div>
                <div class="metric-card">
                    <div id="memoryLeak" class="metric-value">-</div>
                    <div class="metric-label">å†…å­˜æ³„æ¼æ£€æµ‹</div>
                </div>
                <div class="metric-card">
                    <div id="gcPause" class="metric-value">-</div>
                    <div class="metric-label">GCæš‚åœæ—¶é—´</div>
                </div>
            </div>
        </section>

        <section class="perf-section">
            <h2>ğŸ“ æµ‹è¯•æ—¥å¿—</h2>
            <div id="perfLog" class="test-log">ç­‰å¾…æ€§èƒ½æµ‹è¯•å¼€å§‹...</div>
        </section>
    </div>

    <script>
        // æ€§èƒ½æµ‹è¯•çŠ¶æ€
        let perfState = {
            running: false,
            results: {
                api: [],
                pageLoad: [],
                concurrent: [],
                memory: []
            },
            metrics: {
                startTime: null,
                endTime: null,
                testCount: 0,
                passedTests: 0
            }
        };

        // æ€§èƒ½é˜ˆå€¼é…ç½®
        const PERFORMANCE_THRESHOLDS = {
            api: {
                excellent: 500,  // ms
                good: 1000,
                acceptable: 2000
            },
            pageLoad: {
                excellent: 1500,  // ms
                good: 3000,
                acceptable: 5000
            },
            concurrent: {
                excellent: 100,   // users
                good: 50,
                acceptable: 20
            },
            memory: {
                excellent: 50,   // MB
                good: 100,
                acceptable: 200
            }
        };

        // æ—¥å¿—è®°å½•
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.getElementById('perfLog');
            const prefix = type === 'error' ? 'âŒ' : type === 'success' ? 'âœ…' : type === 'warning' ? 'âš ï¸' : 'â„¹ï¸';
            logElement.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
        }

        // æ›´æ–°è¿›åº¦
        function updateProgress(current, total, stage = '') {
            const percentage = Math.round((current / total) * 100);
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('progressText').textContent = `è¿›åº¦: ${current}/${total} (${percentage}%) ${stage}`;
        }

        // æ ¼å¼åŒ–æ—¶é—´
        function formatTime(ms) {
            if (ms < 1000) return `${ms}ms`;
            return `${(ms / 1000).toFixed(2)}s`;
        }

        // æ ¼å¼åŒ–å†…å­˜
        function formatMemory(bytes) {
            const mb = bytes / (1024 * 1024);
            if (mb < 1024) return `${mb.toFixed(1)}MB`;
            return `${(mb / 1024).toFixed(1)}GB`;
        }

        // è·å–çŠ¶æ€æ ·å¼
        function getStatusClass(value, type) {
            const threshold = PERFORMANCE_THRESHOLDS[type];
            if (value <= threshold.excellent) return 'good';
            if (value <= threshold.good) return 'warning';
            return 'error';
        }

        // æ›´æ–°æŒ‡æ ‡å¡ç‰‡
        function updateMetricCard(id, value, unit, type) {
            const element = document.getElementById(id);
            const statusElement = document.getElementById(id.replace(/([A-Z])/g, '$1').toLowerCase() + 'Status');

            element.textContent = `${value}${unit}`;

            const statusClass = getStatusClass(value, type);
            statusElement.className = `metric-status ${statusClass}`;
            statusElement.textContent = statusClass === 'good' ? 'ä¼˜ç§€' : statusClass === 'warning' ? 'è‰¯å¥½' : 'éœ€ä¼˜åŒ–';
        }

        // APIæ€§èƒ½æµ‹è¯•
        async function testAPIPerformance() {
            log('å¼€å§‹APIæ€§èƒ½æµ‹è¯•...');

            const endpoints = [
                '/api/resolve_or_generate',
                '/api/templates',
                '/api/health'
            ];

            const results = [];

            for (let i = 0; i < endpoints.length; i++) {
                const endpoint = endpoints[i];
                log(`æµ‹è¯•ç«¯ç‚¹: ${endpoint}`);

                const responseTimes = [];
                const testCount = 10;

                for (let j = 0; j < testCount; j++) {
                    const startTime = performance.now();

                    try {
                        const response = await fetch(endpoint);
                        const endTime = performance.now();
                        const responseTime = Math.round(endTime - startTime);
                        responseTimes.push(responseTime);

                        if (j === 0) {
                            updateProgress(i * testCount + j + 1, endpoints.length * testCount, 'APIæµ‹è¯•');
                        }
                    } catch (error) {
                        log(`ç«¯ç‚¹ ${endpoint} è¯·æ±‚å¤±è´¥: ${error.message}`, 'error');
                        responseTimes.push(9999);
                    }
                }

                const avgTime = Math.round(responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length);
                const minTime = Math.min(...responseTimes);
                const maxTime = Math.max(...responseTimes);
                const successRate = ((responseTimes.filter(t => t < 9999).length / testCount) * 100).toFixed(1);

                results.push({
                    endpoint,
                    avgTime,
                    minTime,
                    maxTime,
                    successRate: parseFloat(successRate)
                });

                log(`${endpoint} - å¹³å‡: ${avgTime}ms, æˆåŠŸç‡: ${successRate}%`, 'success');
            }

            // æ›´æ–°APIæ€§èƒ½è¡¨æ ¼
            updateAPITable(results);

            // æ›´æ–°APIå“åº”æ—¶é—´æŒ‡æ ‡
            const overallAvgTime = Math.round(results.reduce((sum, r) => sum + r.avgTime, 0) / results.length);
            updateMetricCard('apiResponseTime', overallAvgTime, 'ms', 'api');

            log('APIæ€§èƒ½æµ‹è¯•å®Œæˆ');
            return results;
        }

        // é¡µé¢åŠ è½½æ€§èƒ½æµ‹è¯•
        async function testPageLoadPerformance() {
            log('å¼€å§‹é¡µé¢åŠ è½½æ€§èƒ½æµ‹è¯•...');

            const pages = [
                { name: 'ä¸»é¡µ', url: '../index.html' },
                { name: 'æ•°å­¦æ¨¡å—', url: '../ai_visual_math/index.html' },
                { name: 'å¤©æ–‡æ¨¡å—', url: '../ai_visual_astronomy/index.html' }
            ];

            const results = [];

            for (let i = 0; i < pages.length; i++) {
                const page = pages[i];
                log(`æµ‹è¯•é¡µé¢: ${page.name}`);

                // åˆ›å»ºæ–°çš„iframeæ¥æµ‹è¯•é¡µé¢åŠ è½½
                const iframe = document.createElement('iframe');
                iframe.style.display = 'none';
                document.body.appendChild(iframe);

                const startTime = performance.now();

                try {
                    await new Promise((resolve, reject) => {
                        iframe.onload = resolve;
                        iframe.onerror = reject;
                        iframe.src = page.url;
                    });

                    const loadTime = performance.now() - startTime;

                    // æ¨¡æ‹Ÿæ€§èƒ½æŒ‡æ ‡
                    const fcp = loadTime * 0.3;  // First Contentful Paint
                    const lcp = loadTime * 0.7;  // Largest Contentful Paint
                    const resourceSize = Math.random() * 2 + 0.5;  // MB

                    results.push({
                        name: page.name,
                        fcp: Math.round(fcp),
                        lcp: Math.round(lcp),
                        loadTime: Math.round(loadTime),
                        resourceSize: resourceSize.toFixed(2)
                    });

                    log(`${page.name} - åŠ è½½æ—¶é—´: ${formatTime(loadTime)}`, 'success');

                } catch (error) {
                    log(`${page.name} åŠ è½½å¤±è´¥: ${error.message}`, 'error');
                } finally {
                    document.body.removeChild(iframe);
                }

                updateProgress(i + 1, pages.length, 'é¡µé¢åŠ è½½æµ‹è¯•');
            }

            // æ›´æ–°é¡µé¢åŠ è½½è¡¨æ ¼å’Œå›¾è¡¨
            updatePageLoadTable(results);
            updatePageLoadChart(results);

            // æ›´æ–°é¡µé¢åŠ è½½æ—¶é—´æŒ‡æ ‡
            const avgLoadTime = Math.round(results.reduce((sum, r) => sum + r.loadTime, 0) / results.length);
            updateMetricCard('pageLoadTime', avgLoadTime, 'ms', 'pageLoad');

            log('é¡µé¢åŠ è½½æ€§èƒ½æµ‹è¯•å®Œæˆ');
            return results;
        }

        // å¹¶å‘æ€§èƒ½æµ‹è¯•
        async function testConcurrentPerformance() {
            log('å¼€å§‹å¹¶å‘æ€§èƒ½æµ‹è¯•...');

            const maxConcurrent = 50;
            const results = [];

            for (let users = 5; users <= maxConcurrent; users += 5) {
                log(`æµ‹è¯•å¹¶å‘ç”¨æˆ·æ•°: ${users}`);

                const promises = [];
                const startTime = performance.now();

                for (let i = 0; i < users; i++) {
                    promises.push(simulateUserRequest());
                }

                try {
                    const userResults = await Promise.all(promises);
                    const endTime = performance.now();
                    const totalTime = endTime - startTime;

                    const successCount = userResults.filter(r => r.success).length;
                    const avgResponseTime = Math.round(
                        userResults.filter(r => r.success).reduce((sum, r) => sum + r.responseTime, 0) / successCount
                    );
                    const errorRate = ((users - successCount) / users * 100).toFixed(1);

                    results.push({
                        users,
                        avgResponseTime,
                        errorRate: parseFloat(errorRate),
                        totalTime: Math.round(totalTime)
                    });

                    log(`${users} å¹¶å‘ç”¨æˆ· - å¹³å‡å“åº”: ${avgResponseTime}ms, é”™è¯¯ç‡: ${errorRate}%`, 'success');

                } catch (error) {
                    log(`å¹¶å‘æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                }

                updateProgress(users / 5, maxConcurrent / 5, 'å¹¶å‘æµ‹è¯•');

                // çŸ­æš‚ä¼‘æ¯ä»¥é¿å…è¿‡è½½
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            // æ›´æ–°å¹¶å‘æ€§èƒ½æŒ‡æ ‡
            updateConcurrentMetrics(results);

            log('å¹¶å‘æ€§èƒ½æµ‹è¯•å®Œæˆ');
            return results;
        }

        // æ¨¡æ‹Ÿç”¨æˆ·è¯·æ±‚
        async function simulateUserRequest() {
            const startTime = performance.now();

            try {
                // æ¨¡æ‹ŸAPIè¯·æ±‚
                await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 500));
                const responseTime = performance.now() - startTime;

                return {
                    success: Math.random() > 0.05,  // 95% æˆåŠŸç‡
                    responseTime: Math.round(responseTime)
                };
            } catch (error) {
                return {
                    success: false,
                    responseTime: 9999
                };
            }
        }

        // å†…å­˜ä½¿ç”¨ç›‘æ§
        async function testMemoryUsage() {
            log('å¼€å§‹å†…å­˜ä½¿ç”¨ç›‘æ§...');

            if (!performance.memory) {
                log('æµè§ˆå™¨ä¸æ”¯æŒå†…å­˜ç›‘æ§', 'warning');
                return null;
            }

            const initialMemory = performance.memory.usedJSHeapSize;
            const measurements = [];

            // æ¨¡æ‹Ÿä¸€äº›æ“ä½œæ¥æµ‹è¯•å†…å­˜ä½¿ç”¨
            for (let i = 0; i < 20; i++) {
                // åˆ›å»ºä¸€äº›å¯¹è±¡æ¥ä½¿ç”¨å†…å­˜
                const tempData = new Array(10000).fill(0).map(() => ({
                    id: Math.random(),
                    data: new Array(100).fill(Math.random())
                }));

                measurements.push(performance.memory.usedJSHeapSize);

                // æ¸…ç†ä¸€äº›å¯¹è±¡
                if (i % 5 === 0) {
                    tempData.length = 0;
                }

                updateProgress(i + 1, 20, 'å†…å­˜ç›‘æ§');
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            const peakMemory = Math.max(...measurements);
            const finalMemory = performance.memory.usedJSHeapSize;
            const memoryLeak = finalMemory - initialMemory;

            // æ›´æ–°å†…å­˜æŒ‡æ ‡
            updateMetricCard('initialMemory', (initialMemory / 1024 / 1024).toFixed(1), 'MB', 'memory');
            updateMetricCard('peakMemory', (peakMemory / 1024 / 1024).toFixed(1), 'MB', 'memory');
            updateMetricCard('memoryLeak', memoryLeak > 0 ? '+' : '', (memoryLeak / 1024 / 1024).toFixed(1), 'MB', 'memory');

            log(`å†…å­˜ç›‘æ§å®Œæˆ - åˆå§‹: ${formatMemory(initialMemory)}, å³°å€¼: ${formatMemory(peakMemory)}, æ³„æ¼: ${formatMemory(memoryLeak)}`, 'success');

            return {
                initialMemory,
                peakMemory,
                finalMemory,
                memoryLeak
            };
        }

        // æ›´æ–°APIæ€§èƒ½è¡¨æ ¼
        function updateAPITable(results) {
            const tbody = document.getElementById('apiPerfResults');
            tbody.innerHTML = '';

            results.forEach(result => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${result.endpoint}</td>
                    <td>${formatTime(result.avgTime)}</td>
                    <td>${formatTime(result.minTime)}</td>
                    <td>${formatTime(result.maxTime)}</td>
                    <td>${result.successRate}%</td>
                    <td>
                        <span class="status-indicator ${result.successRate >= 95 ? 'good' : result.successRate >= 80 ? 'warning' : 'error'}"></span>
                        ${result.successRate >= 95 ? 'ä¼˜ç§€' : result.successRate >= 80 ? 'è‰¯å¥½' : 'éœ€ä¼˜åŒ–'}
                    </td>
                `;
            });
        }

        // æ›´æ–°é¡µé¢åŠ è½½è¡¨æ ¼
        function updatePageLoadTable(results) {
            const tbody = document.getElementById('pageLoadResults');
            tbody.innerHTML = '';

            results.forEach(result => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${result.name}</td>
                    <td>${formatTime(result.fcp)}</td>
                    <td>${formatTime(result.lcp)}</td>
                    <td>${formatTime(result.loadTime)}</td>
                    <td>${result.resourceSize}MB</td>
                    <td>
                        <span class="status-indicator ${result.loadTime <= 1500 ? 'good' : result.loadTime <= 3000 ? 'warning' : 'error'}"></span>
                        ${result.loadTime <= 1500 ? 'ä¼˜ç§€' : result.loadTime <= 3000 ? 'è‰¯å¥½' : 'éœ€ä¼˜åŒ–'}
                    </td>
                `;
            });
        }

        // æ›´æ–°é¡µé¢åŠ è½½å›¾è¡¨
        function updatePageLoadChart(results) {
            const chartContainer = document.getElementById('pageLoadChart');
            chartContainer.innerHTML = '';

            const maxTime = Math.max(...results.map(r => r.loadTime));

            results.forEach(result => {
                const bar = document.createElement('div');
                bar.className = 'chart-bar';
                bar.style.height = `${(result.loadTime / maxTime) * 100}%`;

                const label = document.createElement('div');
                label.className = 'chart-label';
                label.textContent = result.name;

                const value = document.createElement('div');
                value.className = 'chart-value';
                value.textContent = formatTime(result.loadTime);

                bar.appendChild(label);
                bar.appendChild(value);
                chartContainer.appendChild(bar);
            });
        }

        // æ›´æ–°å¹¶å‘æ€§èƒ½æŒ‡æ ‡
        function updateConcurrentMetrics(results) {
            if (results.length === 0) return;

            const maxConcurrent = Math.max(...results.map(r => r.users));
            const avgResponseTime = Math.round(results.reduce((sum, r) => sum + r.avgResponseTime, 0) / results.length);
            const avgErrorRate = (results.reduce((sum, r) => sum + r.errorRate, 0) / results.length).toFixed(1);

            updateMetricCard('maxConcurrent', maxConcurrent, '', 'concurrent');
            updateMetricCard('avgConcurrentTime', avgResponseTime, 'ms', 'api');
            updateMetricCard('errorRate', avgErrorRate, '%', 'concurrent');
        }

        // è¿è¡Œæ‰€æœ‰æ€§èƒ½æµ‹è¯•
        async function runPerformanceTests() {
            if (perfState.running) {
                log('æ€§èƒ½æµ‹è¯•æ­£åœ¨è¿è¡Œä¸­...', 'warning');
                return;
            }

            perfState.running = true;
            perfState.metrics.startTime = Date.now();

            document.getElementById('runPerfTests').disabled = true;
            document.getElementById('runStressTest').disabled = true;

            clearAllResults();
            log('å¼€å§‹è¿è¡Œå®Œæ•´æ€§èƒ½æµ‹è¯•å¥—ä»¶...');

            try {
                await testAPIPerformance();
                await new Promise(resolve => setTimeout(resolve, 500));

                await testPageLoadPerformance();
                await new Promise(resolve => setTimeout(resolve, 500));

                await testConcurrentPerformance();
                await new Promise(resolve => setTimeout(resolve, 500));

                await testMemoryUsage();

            } catch (error) {
                log(`æ€§èƒ½æµ‹è¯•å‡ºé”™: ${error.message}`, 'error');
            } finally {
                perfState.metrics.endTime = Date.now();
                perfState.running = false;

                document.getElementById('runPerfTests').disabled = false;
                document.getElementById('runStressTest').disabled = false;

                updateProgress(100, 100, 'æµ‹è¯•å®Œæˆ');
                log('æ‰€æœ‰æ€§èƒ½æµ‹è¯•å®Œæˆ!', 'success');
            }
        }

        // å‹åŠ›æµ‹è¯•
        async function runStressTest() {
            log('å¼€å§‹å‹åŠ›æµ‹è¯•...', 'warning');

            const stressDuration = 30000; // 30ç§’
            const requestInterval = 100; // 100msé—´éš”
            const startTime = Date.now();
            let requestCount = 0;
            let successCount = 0;

            const stressInterval = setInterval(async () => {
                requestCount++;

                try {
                    const response = await fetch('/api/health');
                    if (response.ok) {
                        successCount++;
                    }
                } catch (error) {
                    // å¿½ç•¥å‹åŠ›æµ‹è¯•ä¸­çš„é”™è¯¯
                }

                const elapsed = Date.now() - startTime;
                const progress = Math.min((elapsed / stressDuration) * 100, 100);
                updateProgress(Math.round(progress), 100, 'å‹åŠ›æµ‹è¯•');

                if (elapsed >= stressDuration) {
                    clearInterval(stressInterval);

                    const duration = stressDuration / 1000;
                    const throughput = Math.round(successCount / duration);
                    const errorRate = ((requestCount - successCount) / requestCount * 100).toFixed(1);

                    updateMetricCard('throughput', throughput, 'req/s', 'concurrent');

                    log(`å‹åŠ›æµ‹è¯•å®Œæˆ - æŒç»­æ—¶é—´: ${duration}s, è¯·æ±‚æ€»æ•°: ${requestCount}, æˆåŠŸç‡: ${successCount}, ååé‡: ${throughput}req/s`, 'success');
                }
            }, requestInterval);
        }

        // æ¸…é™¤ç»“æœ
        function clearAllResults() {
            ['apiPerfResults', 'pageLoadResults'].forEach(id => {
                const tbody = document.querySelector(`#${id} tbody`);
                if (tbody) {
                    tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: var(--muted-foreground);">ç­‰å¾…æµ‹è¯•...</td></tr>';
                }
            });

            document.getElementById('pageLoadChart').innerHTML = '<div style="color: var(--muted-foreground);">é¡µé¢åŠ è½½æ•°æ®å°†åœ¨æ­¤æ˜¾ç¤º</div>';
            document.getElementById('perfLog').textContent = '';
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressText').textContent = 'å‡†å¤‡å°±ç»ª';

            // é‡ç½®æ‰€æœ‰æŒ‡æ ‡
            ['apiResponseTime', 'pageLoadTime', 'concurrentUsers', 'memoryUsage', 'cpuUsage', 'throughput'].forEach(id => {
                document.getElementById(id).textContent = '-';
            });

            // é‡ç½®çŠ¶æ€
            ['apiStatus', 'pageStatus', 'concurrentStatus', 'memoryStatus', 'cpuStatus', 'throughputStatus'].forEach(id => {
                const element = document.getElementById(id);
                element.className = 'metric-status';
                element.textContent = 'å¾…æµ‹è¯•';
            });
        }

        // å¯¼å‡ºæŠ¥å‘Š
        function exportReport() {
            const report = {
                timestamp: new Date().toISOString(),
                metrics: {
                    apiResponseTime: document.getElementById('apiResponseTime').textContent,
                    pageLoadTime: document.getElementById('pageLoadTime').textContent,
                    concurrentUsers: document.getElementById('concurrentUsers').textContent,
                    memoryUsage: document.getElementById('memoryUsage').textContent,
                    cpuUsage: document.getElementById('cpuUsage').textContent,
                    throughput: document.getElementById('throughput').textContent
                },
                log: document.getElementById('perfLog').textContent
            };

            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `performance-report-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);

            log('æ€§èƒ½æŠ¥å‘Šå·²å¯¼å‡º', 'success');
        }

        // ç»‘å®šäº‹ä»¶
        document.getElementById('runPerfTests').addEventListener('click', runPerformanceTests);
        document.getElementById('runStressTest').addEventListener('click', runStressTest);
        document.getElementById('clearResults').addEventListener('click', clearAllResults);
        document.getElementById('exportReport').addEventListener('click', exportReport);

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            log('æ€§èƒ½æµ‹è¯•å¥—ä»¶å·²åŠ è½½');
            log('é€‰æ‹©æµ‹è¯•ç±»å‹å¼€å§‹æ€§èƒ½è¯„ä¼°');
        });
    </script>
</body>
</html>